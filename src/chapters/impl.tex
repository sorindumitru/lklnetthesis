\chapter{Implementation}
\label{chapter:impl}

The linux kernel offers great support for turning an ordinary computer into a network
device. It allows to modify the routing table through NETLINK sockets, creating
and destroying virtual bridging interfaces, adding and removing firewall rules through 
iptables. I used some of these capabilities to implement the devices described in this 
chapt	

\section{Switch}
\label{sec:switch-impl}

\subsection{Linux support}
\label{sub-sec:switch-lin}

Linux offers support for bridging through virtual interfaces. A bridge interface
can be create through code, as seen in \ref{lst:cbridgeadd}, or using the bridge-utils
package:
\lstset{language=zsh,caption=Adding a bridge interface,label=lst:sbridgeadd}
\begin{lstlisting}
  #> brctl add br0
\end{lstlisting}
Because the created interface is a virtual one, it cannot be used by itself to receive packats
from the network. In order to do this, physical interfaces must be added to the bridge. This 
can be done using brctl:
\lstset{language=zsh,caption=Adding a bridge interface,label=lst:sportadd}
\begin{lstlisting}
  #> brctl addif br0 eth0
\end{lstlisting}
where br0 is the name of the virtual interface and eth0 the name of the physical one.

Other features:
\begin{itemize}
  \item STP
  \item Multiple bridge instances
  \item Firewalling through ebtables
\end{itemize}
Of these, only STP support has been implemented in \textbf{\project}.

To enable bridgin support in the kernel, the ``networking->802.1d Ethernet Bridging'' option
must be set. This is done in the kernel configuration that comes with \textbf{\project}.

\subsection{\text{\project} implementation}
\label{sub-sec:switch-lkl}

The linux kernel offers an interface to configure bridging. This interface is used
by existing user space applications, so this is the interface we chose for the switch device. 
It uses the ioctl syscall(lkl_sys_ioctl in LKL):
\begin{description}
  \item[SIOCBRADDBR] \hfill \\
  Is used to create a new bridging virtual inteface. It takes the name of the new interface as parameter.
  \item[SIOCBRDELBR] \hfill \\
  Is used to destroy a bridging interface. It takes the name of the new interface as parameter.
  \item[SIOCBRADDIF] \hfill \\
  Is used to add a physical interface as a port to the bridge. It takes as parameter a ifreq structure containing
the interface index of the phyisical interface and the interface name of the bridge.
  \item[SIOCBRDELIF] \hfill \\
  Is used to delete a physical interface from the bridge. It takes as parameter a ifreq structure containing
  \item[SIOCDEVPRIVATE] \hfill \\
  Is used for the remaining operations: getting information about the interfaces, setting STP on/off and getting information
about STP.
\end{description}
An example of adding a new bridge interface:

\lstset{language=C,caption=Add bridge,label=lst:cbridgeadd}
\lstinputlisting{src/code/bridge/bridgeadd.c}

\subsection{Device tests}
\label{sub-sec:switch-tests}

\section{Firewall}
\label{sub-sec:firewall-impl}

\subsection{Linux support}
\label{sub-sec:firewall-lin}

IPtables is the user space program used in linux to control the firewall tables from the kernel. It is based
ont the netfitler project, which was started in 1998 by Rusty Russell. Prior to this, ipchain was used to do
this task in Linux 2.2 and ipfwadmin in Linux 2.0.

Netfilter is framework for packet mangling. It defines per protocol hooks, which are points in the network code
where the framework is called. Ipv4 defines 5 such points:
\begin{itemize}
  \item PREROUTING. It is called after the packet is received but after sanity checks have been made on it.
  \item INPUT. It is called if the packet is for this host.
  \item OUTPUT.	It is called for locally generated packets.
  \item FORWARD. It is called if the destination of the packet isn't this machine.
  \item POSTROUTING. It is called before the packets are sent to the network driver.
\end{itemize}
The route that the packets take is described in figure \ref{img:netfilter}.
\fig[scale=0.5]{src/img/netfilter.pdf}{img:netfilter}{Netfilter hooks}
Tables

Chains

An iptables rule is represented by an ipt_entry structure in the kernel. It contains an ipt_ip structure, information used
to retrieve the target, a list of ipt_matches structures and a target. The ipt_ip structure contains general information for
level 3 matching of packets: source and destination address, input and output port, protocol. Ipt_matches allow matching of
packets based on more parameters than standard rules, for example address type. The target picks the submodule that handles the 
packet and stores additional data used by the module.

\subsection{\text{\project} implementation}
\label{sub-sec:firewall-lkl}

Libiptc is the library used by the iptables project to comunicate with netfilter. It allows
querying the kernel for netfilter rules, and saving changes back to the kernel. The data from
the kernel comes as one blob:
\lstset{language=C,caption=Getting firewall rules,label=lst:sgetrule}
\begin{lstlisting}
size = sizeof(info);
getsockopt(socket, IPPROTO_IP, SO_GET_INFO, &info, &size); 
size = sizeof(ipt_get_entries) + info.size;
getsockopt(socket, IPPROTO_IP, SO_GET_ENTRIES, buffer, &size);
\end{lstlisting}
libitpc parses the entries from it, puts each rule in its chain and stores the chains in an iptc_handle. This allows for a simple way
of view and working with the rules, because we don't have to parse the blob each time. When we add a new rule
it is not imediately added to the kernel, instead they are added to the iptc_handle. When we want them to be added to the kernel,
this is done through iptc_commit which call setsockopt:
\lstset{language=C,caption=Commiting changes,label=lst:ssetrules}
\begin{lstlisting}
struct ipt_replace *replace;
// add entries from iptc_handle to replace
setsockopt(socket, IPPROTO_IP, SO_GET_ENTRIES, replace, sizeof(*replace) + replace->size);
\end{lstlisting}
We have ported this library to the LKL project so we can use it in the rest of the code. This was mostly done by replacing
the syscalls from it with lkl syscall( lkl_sys prefix).

The targets used by the filtering module of \text{\project} uses only the standard data. This is one of the simplest targets
used by iptables; it contains only data about its size and the verdict for the packet( ACCEPT, DROP or DENY).

\begin{description}
\item[Adding rules] \hfill \\
Adding rules can be done by taking all the rules from the kernel, creating a 
new rule, inserting the rule in the blob from the kernel and committing it back
to the kernel. This is done with the following command:
\lstset{language=zsh,caption=Adding a rule,label=lst:saddrule}
\begin{lstlisting}
filter -A chain [-s saddr -d daddr -i iif -o oif] -j ACCEPT|DROP|DENY
\end{lstlisting}
\item[Removing rules] \hfill \\
Removing a rules is done by specifing the chain and rule number:
\lstset{language=zsh,caption=Deleting a rule,label=lst:sdelrule}
\begin{lstlisting}
filter -D chain rulenumber
\end{lstlisting}
\item[Listing rules] \hfill \\
Rules can be listed for a specified chain or for all the chains if one isn't specified.
\lstset{language=zsh,caption=List rules,label=lst:slstrule}
\begin{lstlisting}
filter -L [chain]
\end{lstlisting}
\end{description}

\subsection{Device tests}
\label{sub-sec:firewall-tests}

\section{Bridge}

\subsection{Linux support}
\label{sub-sec:bridge-lin}

TUN/TAP interfaces are virtual interfaces provided by the kernel. Unlike regular interfaces
these are handled in software. Packets sent through a TUN/TAP interface are received in
an userspace program through a file descriptor created upon opening the interface: 

\lstset{language=C,caption=Opening a tun/tap interface,label=lst:tapopen}
\lstinputlisting{src/code/tap/open.c}

TUN interfaces operates with layer 3 packets, while TAP interfaces operate with layer 
2 packets such as Ethernet frames. TUN interfaces can be used to create tunnels( Vtun)
or VPN(OpenVPN); TAP interfaces are used to create virtual interfaces for applications 
that do virtualization(VirtualBox).

\subsection{\text{\project} implementation}
\label{sub-sec:bridge-lkl}

One of the objectives of the project was to not isolate the simulated devices from other user space 
programs. Two possible solutions for this were found:
\begin{itemize}
  \item Using raw sockets as a base for an interface.
  \item Creatinga a new device that uses a TAP interface to interconect a normal application.
\end{itemize}

At first we tried to use the first approach but we encountered some problems with network loops.
We have chosen the second approach because of this and because it allows us to have a better visualisation of the packet
as it traverses the network; the socket can be seen in the same way as an ethernet cable and so it allows
us to watch the packet on the network.

\fig[scale=0.5]{src/img/bridge.pdf}{img:bridge}{Bridge}

As it can be seen in figure \ref{img:bridge} the bridge has two interfaces; the TAP interface that is used to 
receive packets from user space programs and a socket interface that is used to connect, through a hub, to 
a LKL device. Upon receiving a packets it modifies it by adding the total length of it and sends it to a hub 
through a socket.

\subsection{Device tests}
\label{sub-sec:bridge-tests}

\section{Hypervisor}
\label{sec:hypervisor2}

\section{Console and configuration file}
\label{sec:dev-conf}

FLEX

CONSOLE