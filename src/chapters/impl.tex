\chapter{Implementation}
\label{chapter:impl}

The linux kernel offers great support for turning an ordinary computer into a network
device. It allows to modify the routing table through NETLINK sockets, creating
and destroying virtual bridging interfaces, adding and removing firewall rules through 
iptables. I used some of these capabilities to implement the devices described in this 
chapt	

\section{Network driver}
\label{sec:net-driver}

\fig[scale=0.5]{src/img/driver.pdf}{img:eth-driver}{Network driver}

The network driver is split into two separate parts: a LKL part and a native part.

The lkl part takes care of the interaction with the lkl kernel. It encapsulates
and decapsulates the packets for the kernel(encapsulates them in a struct sk_buff)
and the native part.

The native part uses native syscalls to assure communication between two devices.
It can use any inter-process communication primitives like pipes, mail queues or sockets.
For this implementation we have chosen to use sockets so that it will be possible
to connect two devices on different computers.

\section{Switch}
\label{sec:switch-impl}

In the next section a switch is called a bridge, as this the terminology used by the linux kernel.

\subsection{Linux support}
\label{sub-sec:switch-lin}

Linux offers support for bridging through virtual interfaces. A bridge interface
can be create through code, as seen in \ref{lst:cbridgeadd}, or using the bridge-utils
package:
\lstset{language=zsh,caption=Adding a bridge interface,label=lst:sbridgeadd}
\begin{lstlisting}
  #> brctl add br0
\end{lstlisting}
Because the created interface is a virtual one, it cannot be used by itself to receive packats
from the network. In order to do this, physical interfaces must be added to the bridge. This 
can be done using brctl:
\lstset{language=zsh,caption=Adding a bridge interface,label=lst:sportadd}
\begin{lstlisting}
  #> brctl addif br0 eth0
\end{lstlisting}
where br0 is the name of the virtual interface and eth0 the name of the physical one.

Other features:
\begin{itemize}
  \item STP
  \item Multiple bridge instances
  \item Firewalling through ebtables
\end{itemize}
Of these, only STP support has been implemented in \textbf{\project}.

To enable bridgin support in the kernel, the ``networking->802.1d Ethernet Bridging'' option
must be set. This is done in the kernel configuration that comes with \textbf{\project}.

\subsection{\text{\project} implementation}
\label{sub-sec:switch-lkl}

The linux kernel offers an interface to configure bridging. This interface is used
by existing user space applications, so this is the interface we chose for the switch device. 
It uses the ioctl syscall(lkl_sys_ioctl in LKL):
\begin{description}
  \item[SIOCBRADDBR] \hfill \\
  Is used to create a new bridging virtual inteface. It takes the name of the new interface as parameter.
  \item[SIOCBRDELBR] \hfill \\
  Is used to destroy a bridging interface. It takes the name of the new interface as parameter.
  \item[SIOCBRADDIF] \hfill \\
  Is used to add a physical interface as a port to the bridge. It takes as parameter a ifreq structure containing
the interface index of the phyisical interface and the interface name of the bridge.
  \item[SIOCBRDELIF] \hfill \\
  Is used to delete a physical interface from the bridge. It takes as parameter a ifreq structure containing
  \item[SIOCDEVPRIVATE] \hfill \\
  Is used for the remaining operations: getting information about the interfaces, setting STP on/off and getting information
about STP.
\end{description}
An example of adding a new bridge interface:

\lstset{language=C,caption=Add bridge,label=lst:cbridgeadd}
\lstinputlisting{src/code/bridge/bridgeadd.c}

\subsection{Device tests}
\label{sub-sec:switch-tests}

\section{Firewall}
\label{sub-sec:firewall-impl}

\subsection{Linux support}
\label{sub-sec:firewall-lin}

IPtables is the user space program used in linux to control the firewall tables from the kernel. It is based
ont the netfitler project, which was started in 1998 by Rusty Russell. Prior to this, ipchain was used to do
this task in Linux 2.2 and ipfwadmin in Linux 2.0.

Netfilter is framework for packet mangling. It defines per protocol hooks, which are points in the network code
where the framework is called. Ipv4 defines 5 such points:
\begin{itemize}
  \item PREROUTING. It is called after the packet is received but after sanity checks have been made on it.
  \item INPUT. It is called if the packet is for this host.
  \item OUTPUT.	It is called for locally generated packets.
  \item FORWARD. It is called if the destination of the packet isn't this machine.
  \item POSTROUTING. It is called before the packets are sent to the network driver.
\end{itemize}
The route that the packets take is described in \figref{img:netfilter}.
\fig[scale=0.5]{src/img/netfilter.pdf}{img:netfilter}{Netfilter hooks}

The ip_tables kernel module uses the netfilter framework to define tables that can be used to build firewall rules.
Each table containes on or more chains the map to the netfilter hooks previously discused. 
The IPv4 protocol has three tables defined:
\begin{itemize}
  \item filter. The filter table is used, as its name implies, to filter packets, it should not be used for packet mangling. The chains
avaible in this table are INPUT, OUTPUT and FORWARD.
  \item nat. The nat table is used for network address translation. The chains that are available in this table are PREROUTING,
 POSTROUTING and OUTPUT
  \item mangle. The mangle table is used to modify packets, it can be used for example to change the TTL field in
the IPv4 header. The mangle table can use all five hooks of the IPv4 protocol.
\end{itemize}

Each chain contains a number of rules. When a packet passes through the netfilter hook coresponding to the chain each rule is checked
for a match; if a match is found, the action of the rule is applied; if no rule matches the packet, the policy of the chain is applied.
The predefined chains have a default policy of \textbf{ACCEPT}, meaning that if no rule matches the packet, it is accepted, but this behavior
can be changed. Users can define new chains; this chains have no policy, instead they return to the calling chain if no rule is matched.
The jump option(-j CHAIN) can be used to call a user defined chain.

An iptables rule is represented by an ipt_entry structure in the kernel. It contains an ipt_ip structure, information used
to retrieve the target, a list of ipt_matches structures and a target. The ipt_ip structure contains general information for
level 3 matching of packets: source and destination address, input and output port, protocol. Ipt_matches allow matching of
packets based on more parameters than standard rules, for example address type. The target picks the submodule that handles the 
packet and stores additional data used by the module.

\subsection{\text{\project} implementation}
\label{sub-sec:firewall-lkl}

Libiptc is the library used by the iptables project to comunicate with netfilter. It allows
querying the kernel for netfilter rules, and saving changes back to the kernel. The data from
the kernel comes as one blob:
\lstset{language=C,caption=Getting firewall rules,label=lst:sgetrule}
\begin{lstlisting}
size = sizeof(info);
getsockopt(socket, IPPROTO_IP, SO_GET_INFO, &info, &size); 
size = sizeof(ipt_get_entries) + info.size;
getsockopt(socket, IPPROTO_IP, SO_GET_ENTRIES, buffer, &size);
\end{lstlisting}
libitpc parses the entries from it, puts each rule in its chain and stores the chains in an iptc_handle. This allows for a simple way
of view and working with the rules, because we don't have to parse the blob each time. When we add a new rule
it is not imediately added to the kernel, instead they are added to the iptc_handle. When we want them to be added to the kernel,
this is done through iptc_commit which call setsockopt:
\lstset{language=C,caption=Commiting changes,label=lst:ssetrules}
\begin{lstlisting}
struct ipt_replace *replace;
// add entries from iptc_handle to replace
setsockopt(socket, IPPROTO_IP, SO_GET_ENTRIES, replace, sizeof(*replace) + replace->size);
\end{lstlisting}
We have ported this library to the LKL project so we can use it in the rest of the code. This was mostly done by replacing
the syscalls from it with lkl syscall( lkl_sys prefix).

The targets used by the filtering module of \text{\project} uses only the standard data. This is one of the simplest targets
used by iptables; it contains only data about its size and the verdict for the packet( ACCEPT, DROP or DENY).

\begin{description}
\item[Adding rules] \hfill \\
Adding rules can be done by taking all the rules from the kernel, creating a 
new rule, inserting the rule in the blob from the kernel and committing it back
to the kernel. This is done with the following command:
\lstset{language=zsh,caption=Adding a rule,label=lst:saddrule}
\begin{lstlisting}
filter -A chain [-s saddr -d daddr -i iif -o oif] -j ACCEPT|DROP|DENY
\end{lstlisting}
\item[Removing rules] \hfill \\
Removing a rules is done by specifing the chain and rule number:
\lstset{language=zsh,caption=Deleting a rule,label=lst:sdelrule}
\begin{lstlisting}
filter -D chain rulenumber
\end{lstlisting}
\item[Listing rules] \hfill \\
Rules can be listed for a specified chain or for all the chains if one isn't specified.
\lstset{language=zsh,caption=List rules,label=lst:slstrule}
\begin{lstlisting}
filter -L [chain]
\end{lstlisting}
\end{description}

\subsection{Device tests}
\label{sub-sec:firewall-tests}

\section{Bridge}

\subsection{Linux support}
\label{sub-sec:bridge-lin}

TUN/TAP interfaces are virtual interfaces provided by the kernel. Unlike regular interfaces
these are handled in software. Packets sent through a TUN/TAP interface are received in
an userspace program through a file descriptor created upon opening the interface: 

\lstset{language=C,caption=Opening a tun/tap interface,label=lst:tapopen}
\lstinputlisting{src/code/tap/open.c}

TUN interfaces operates with layer 3 packets, while TAP interfaces operate with layer 
2 packets such as Ethernet frames. TUN interfaces can be used to create tunnels( Vtun)
or VPN(OpenVPN); TAP interfaces are used to create virtual interfaces for applications 
that do virtualization(VirtualBox).

\subsection{\text{\project} implementation}
\label{sub-sec:bridge-lkl}

One of the objectives of the project was to not isolate the simulated devices from other user space 
programs. Two possible solutions for this were found:
\begin{itemize}
  \item Using raw sockets as a base for an interface.
  \item Creatinga a new device that uses a TAP interface to interconect a normal application.
\end{itemize}

At first we tried to use the first approach but we encountered some problems with network loops.
We have chosen the second approach because of this and because it allows us to have a better visualisation of the packet
as it traverses the network; the socket can be seen in the same way as an ethernet cable and so it allows
us to watch the packet on the network.

\fig[scale=0.5]{src/img/bridge.pdf}{img:bridge}{Bridge}

As it can be seen in \figref{img:bridge} the bridge has two interfaces; the TAP interface that is used to 
receive packets from user space programs and a socket interface that is used to connect, through a hub, to 
a LKL device. Upon receiving a packets it modifies it by adding the total length of it and sends it to a hub 
through a socket.

\subsection{Device tests}
\label{sub-sec:bridge-tests}

\section{Hypervisor}
\label{sec:hypervisor2}

Devices can be started individualy, by giving them a configuration file or no file, in which case the device
will be empty(no interfaces). After the device is started the user can proceed to issue commands( see \appref{chapter:commands} 
for a complete listing of available commands) to configure the device. Starting a large number of
devices and configuring them can a time-consuming task, so we decided on building a GUI application to visualise and configure
the topology, as well as starting and stoping the devices.

\fig[scale=0.44]{src/img/gui.png}{img:gui}{GUI}

THe GUI was built using the GTK library\footnote{\url{http://www.gtk.org/}}. For the topology we created a new GTK widget
that allows us to create and place new devices in the topology as well as creating links between them. In order to draw
the devices on the topology we used the Cairo library, which can be used to draw on GTK widget.

Apart from creating the network topology, the GUI can be used to do some of the configuration of the devices. This is 
more user-friendly than the command line interface used in the devices, so some user might prefer it. Users can also see
the saved configuration of the devices.

\section{Console and configuration file}
\label{sec:dev-conf}

Because we don't always want to start with an empty device and wanted to make de application easy to use, we decieded that the
devices should have configuration, that they could save their current configuration and reopen upon restart. 

We used flex \footnote{\url{http://flex.sourceforge.net}} to parse configuration files. The flex acts like a lexicar analyser, 
parsing the input and transforming them into tokens. Flex is called through the yylex() function to read in a new symbol, and the
symbol is received through the yytext variabile. Checks are done on the variabile and on the input so the function that reads in 
the config file acts like a parser. All the configuration variabiles are stored in a config_info_t structure.

A sample configuration for a switch with two ports:
\lstset{language=inform,caption=Example switch configuration file,label=lst:dconf}
\lstinputlisting{src/code/conf}

At the top of the configurate general informations about the device can be found. Hostname is the name of the device;
The ipaddress and the port are the IPv4 address of the machine where the device is started and the port that the device
uses to communicate with the hub; they are not of much use to the device, but are important for the hypervisor.
After that comes a list of interfaces.	Each interface contains the information to create a new interface a bring it up.
The gateway, port and type are used to create a link with a hub; the type field is necesary because the connection between
to devices can be made through a hub or directly between the devices. 

The switch requires some extra configuration in order to be able to create mutiple bridging virtual interfaces. 
Under the switch portion multiple defined interfaces can be grouped into a bridging interface.

The hypervisor has a slightly different configuration file:
\lstset{language=inform,caption=Example hypervisor configuration file,label=lst:hconf}
\lstinputlisting{src/code/hyperconf}
This configuration file has a list of the devices from the topology and for each device the information needed by the hypervisor to
start the device. Each device have a few variables in common, such as the type of the device, their hostname and their position on
the topology in the gui. LKL devices, such as the switch and the firewall, need a configuration file, so it is specified in the
config file. The hub needs to know the port on which it listens, so it is given to it.

Although basic configuration( routing activation, creating virtual bridging interfaces) can be done through the 
configuration files, it was necessary to implement a command line interface(CLI) for the devices to do additional configurations; 
for example to add a rule to a firewall table or to list the device's interface. We used the readline library, that is used in various
other console-like applications, the create this CLI. Using it, it was very easy to integrate history and autocomplete in our CLI.

To implement history into the the command line we only needed to inform autocomplete of the inserted commands. This is done through the
add_history function. After this the complete history of the commands can be browesed using the up and down keys.

Autocompletion is added by modifing a function pointer from libreadline, rl_completion_entry_function. The function to which it points
is called every time when TAB is pressed. The function then parses the list of avaible commands and sees what possible completions
can follow. 

The complete list of device commands can be found in \appref{chapter:commands}. Not all of these commands are available in every device.